// Load environment variables from parent directory
require('dotenv').config({ path: '../.env' });

const express = require('express');
const logger = require('./utils/logger');
const cors = require('cors');
const axios = require('axios');
const cheerio = require('cheerio');
const robotsParser = require('robots-parser');
const { URL } = require('url');

const app = express();
const PORT = process.env.PORT || 3001;

// CORS configuration for production
const corsOptions = {
  origin: process.env.CORS_ORIGIN || process.env.NODE_ENV === 'production'
    ? ['https://collageforge.onrender.com', 'https://collageforge-frontend.onrender.com']
    : ['http://localhost:3000'],
  credentials: true,
  optionsSuccessStatus: 200
};

app.use(cors(corsOptions));
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Add request logging middleware
app.use(logger.requestMiddleware());

const MAX_IMAGES = 50;
const MAX_TIME_MS = 3 * 60 * 1000; // 3 minutes
const USER_AGENT = 'ImageCrawlerBot/1.0';

class ImageCrawler {
  constructor() {
    this.startTime = 0;
    this.foundImages = new Set();
    this.visitedUrls = new Set();
  }

  async crawl(startUrl, requestId = 'unknown') {
    this.startTime = Date.now();
    this.foundImages.clear();
    this.visitedUrls.clear();

    logger.logCrawlStart(startUrl, requestId);

    try {
      const normalizedUrl = this.normalizeUrl(startUrl);
      const images = [];

      // Check robots.txt for the main domain
      const robotsAllowed = await this.checkRobotsTxt(normalizedUrl);
      if (!robotsAllowed) {
        logger.warn('Crawling blocked by robots.txt', {
          component: 'Crawler',
          action: 'robots_blocked',
          requestId,
          url: normalizedUrl
        });
        return {
          images: [],
          error: 'Crawling not allowed by robots.txt'
        };
      }

      // Crawl the main URL
      await this.crawlUrl(normalizedUrl, images, 0, requestId);

      const duration = Date.now() - this.startTime;
      logger.logCrawlComplete(startUrl, images.length, duration, requestId);

      return { images };
    } catch (error) {
      logger.logCrawlError(startUrl, error, requestId);
      return {
        images: [],
        error: error.message || 'Unknown error occurred'
      };
    }
  }

  async crawlUrl(url, images, depth, requestId = 'unknown') {
    if (this.shouldStop() || this.visitedUrls.has(url) || depth > 1) {
      return;
    }

    this.visitedUrls.add(url);
    logger.debug(`Crawling URL: ${url} (depth: ${depth})`, {
      component: 'Crawler',
      action: 'crawl_url',
      requestId,
      url,
      depth
    });

    try {
      const response = await axios.get(url, {
        timeout: 10000,
        headers: {
          'User-Agent': USER_AGENT,
        },
        maxRedirects: 5,
      });

      const $ = cheerio.load(response.data);

      // Extract images from current page
      this.extractImages($, url, images);

      // If we're at depth 0, crawl one level deeper
      if (depth === 0) {
        const links = this.extractLinks($, url);

        for (const link of links.slice(0, 10)) { // Limit to 10 links
          if (this.shouldStop()) break;

          const robotsAllowed = await this.checkRobotsTxt(link);
          if (robotsAllowed) {
            await this.crawlUrl(link, images, depth + 1, requestId);
          }
        }

        // Log progress periodically
        if (images.length > 0 && images.length % 10 === 0) {
          logger.logCrawlProgress(url, images.length, requestId);
        }
      }
    } catch (error) {
      logger.warn(`Failed to crawl ${url}`, {
        component: 'Crawler',
        action: 'crawl_url_error',
        requestId,
        url,
        error: error.message
      });
    }
  }

  extractImages($, sourceUrl, images) {
    $('img').each((_, element) => {
      if (this.shouldStop()) return false;

      const src = $(element).attr('src');
      if (!src) return;

      const absoluteUrl = this.resolveUrl(src, sourceUrl);
      if (absoluteUrl && !this.foundImages.has(absoluteUrl)) {
        // Filter out very small images and common non-content images
        const width = $(element).attr('width');
        const height = $(element).attr('height');
        const alt = $(element).attr('alt') || '';

        // Skip tiny images, tracking pixels, and common UI elements
        if (width && height && (parseInt(width) < 50 || parseInt(height) < 50)) {
          return;
        }

        if (alt.toLowerCase().includes('pixel') ||
          absoluteUrl.includes('tracking') ||
          absoluteUrl.includes('analytics') ||
          absoluteUrl.includes('beacon')) {
          return;
        }

        this.foundImages.add(absoluteUrl);

        images.push({
          url: absoluteUrl,
          sourceUrl,
          alt: alt
        });

        logger.debug(`Found image: ${absoluteUrl}`, {
          component: 'Crawler',
          action: 'image_found',
          imageUrl: absoluteUrl,
          sourceUrl,
          alt
        });
      }
    });
  }

  extractLinks($, baseUrl) {
    const links = [];
    const baseDomain = new URL(baseUrl).hostname;

    $('a[href]').each((_, element) => {
      const href = $(element).attr('href');
      const rel = $(element).attr('rel');

      // Respect nofollow
      if (rel && rel.includes('nofollow')) {
        return;
      }

      if (href) {
        const absoluteUrl = this.resolveUrl(href, baseUrl);
        if (absoluteUrl) {
          try {
            const linkDomain = new URL(absoluteUrl).hostname;
            // Only follow links within the same domain
            if (linkDomain === baseDomain && !this.visitedUrls.has(absoluteUrl)) {
              links.push(absoluteUrl);
            }
          } catch (e) {
            // Invalid URL, skip
          }
        }
      }
    });

    return links;
  }

  async checkRobotsTxt(url) {
    try {
      const robotsUrl = new URL('/robots.txt', url).toString();
      const response = await axios.get(robotsUrl, {
        timeout: 5000,
        headers: { 'User-Agent': USER_AGENT }
      });

      const robots = robotsParser(robotsUrl, response.data);
      const urlPath = new URL(url).pathname;

      return robots.isAllowed(USER_AGENT, urlPath) !== false;
    } catch (error) {
      // If robots.txt doesn't exist or can't be fetched, assume crawling is allowed
      return true;
    }
  }

  shouldStop() {
    return (
      this.foundImages.size >= MAX_IMAGES ||
      Date.now() - this.startTime >= MAX_TIME_MS
    );
  }

  normalizeUrl(url) {
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      url = 'https://' + url;
    }
    return url;
  }

  resolveUrl(url, base) {
    try {
      return new URL(url, base).toString();
    } catch {
      return null;
    }
  }
}

// API endpoint
app.post('/api/crawl', logger.trackApiEndpoint('/api/crawl'), async (req, res) => {
  const { url } = req.body;
  const requestId = req.requestId;

  if (!url) {
    logger.warn('Crawl request missing URL', {
      component: 'API',
      action: 'validation_error',
      requestId
    });
    return res.status(400).json({ error: 'URL is required' });
  }

  logger.info(`Starting crawl for: ${url}`, {
    component: 'API',
    action: 'crawl_request',
    requestId,
    targetUrl: url
  });

  const crawler = new ImageCrawler();
  const result = await crawler.crawl(url, requestId);

  logger.info(`Crawl completed. Found ${result.images.length} images`, {
    component: 'API',
    action: 'crawl_response',
    requestId,
    targetUrl: url,
    imageCount: result.images.length,
    hasError: !!result.error
  });

  res.json(result);
});

app.get('/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() });
});

// Production error handling
process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection at:', { promise, reason });
  process.exit(1);
});

// AI Image Blending with Google Imagen API
const { GoogleGenerativeAI } = require('@google/generative-ai');
const multer = require('multer');
const sharp = require('sharp');

// Configure multer for file uploads
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files are allowed'), false);
    }
  }
});

// Initialize Google AI
logger.info(`ğŸ”‘ Google AI API Key: ${process.env.GOOGLE_AI_API_KEY ? 'Loaded' : 'Missing'}`);
const genAI = process.env.GOOGLE_AI_API_KEY ? new GoogleGenerativeAI(process.env.GOOGLE_AI_API_KEY) : null;

class AIImageService {
  constructor() {
    this.model = genAI ? genAI.getGenerativeModel({ model: "gemini-pro-vision" }) : null;
  }

  async blendImages(baseImageUrl, userImageBuffer, text, prompt, style = 'realistic', requestId = 'unknown') {
    const startTime = Date.now();
    logger.logAIProcessStart(baseImageUrl, requestId);

    try {
      // Check if AI service is available
      if (!this.model) {
        logger.warn('AI service unavailable - missing API key', {
          component: 'AI',
          action: 'service_unavailable',
          requestId
        });
        return {
          success: false,
          error: 'Google AI API key not configured. Please add GOOGLE_AI_API_KEY to your environment variables.'
        };
      }
      // Download base image
      const baseImageResponse = await axios.get(baseImageUrl, {
        responseType: 'arraybuffer',
        timeout: 10000,
        headers: {
          'User-Agent': USER_AGENT
        }
      });

      const baseImageBuffer = Buffer.from(baseImageResponse.data);

      // Process images with Sharp
      let processedBaseImage = await sharp(baseImageBuffer)
        .resize(1024, 1024, { fit: 'inside', withoutEnlargement: true })
        .jpeg({ quality: 90 })
        .toBuffer();

      let processedUserImage = null;
      if (userImageBuffer) {
        processedUserImage = await sharp(userImageBuffer)
          .resize(1024, 1024, { fit: 'inside', withoutEnlargement: true })
          .jpeg({ quality: 90 })
          .toBuffer();
      }

      // Create prompt for AI
      let aiPrompt = this.buildBlendPrompt(text, prompt, style);

      // Prepare images for AI
      const imageParts = [
        {
          inlineData: {
            data: processedBaseImage.toString('base64'),
            mimeType: 'image/jpeg'
          }
        }
      ];

      if (processedUserImage) {
        imageParts.push({
          inlineData: {
            data: processedUserImage.toString('base64'),
            mimeType: 'image/jpeg'
          }
        });
      }

      // Note: Google's Gemini Pro Vision can analyze images but doesn't generate new images
      // For actual image generation, you would need to use Google's Imagen API
      // This is a placeholder implementation that would need the actual Imagen API

      // For demo purposes, return the base image as a "blended" result
      // In production, this would be replaced with actual AI image generation
      const duration = Date.now() - startTime;
      logger.logAIProcessComplete(true, duration, requestId);

      logger.info('AI blending completed (demo mode)', {
        component: 'AI',
        action: 'blend_complete_demo',
        requestId,
        baseImageUrl,
        hasUserImage: !!userImageBuffer,
        hasText: !!text,
        hasPrompt: !!prompt,
        style,
        duration: `${duration}ms`
      });

      return {
        success: true,
        imageUrl: baseImageUrl,
        message: 'Demo: Returning base image as AI-blended result. Actual AI generation requires Google Imagen API.'
      };

    } catch (error) {
      const duration = Date.now() - startTime;
      logger.logAIProcessComplete(false, duration, requestId);

      logger.error('AI Image Blending Error', error, {
        component: 'AI',
        action: 'blend_error',
        requestId,
        baseImageUrl
      });

      return {
        success: false,
        error: error.message || 'Failed to blend images'
      };
    }
  }

  buildBlendPrompt(text, prompt, style) {
    let aiPrompt = `Create a ${style} style image that blends the provided images`;

    if (text) {
      aiPrompt += ` and includes the text "${text}"`;
    }

    if (prompt) {
      aiPrompt += `. Additional instructions: ${prompt}`;
    }

    aiPrompt += '. Make it visually appealing and cohesive.';

    return aiPrompt;
  }
}

const aiImageService = new AIImageService();

// AI Image Blending endpoint
app.post('/api/ai/blend-images', logger.trackApiEndpoint('/api/ai/blend-images'), upload.single('userImage'), async (req, res) => {
  const requestId = req.requestId;

  try {
    const { baseImageUrl, text, prompt, style } = req.body;

    logger.info('AI blend request received', {
      component: 'API',
      action: 'ai_blend_request',
      requestId,
      baseImageUrl,
      hasUserImage: !!req.file,
      hasText: !!text,
      hasPrompt: !!prompt,
      style
    });

    if (!baseImageUrl) {
      logger.warn('AI blend request missing base image URL', {
        component: 'API',
        action: 'validation_error',
        requestId
      });
      return res.status(400).json({
        success: false,
        error: 'Base image URL is required'
      });
    }

    const userImageBuffer = req.file ? req.file.buffer : null;

    const result = await aiImageService.blendImages(
      baseImageUrl,
      userImageBuffer,
      text,
      prompt,
      style,
      requestId
    );

    logger.info('AI blend response sent', {
      component: 'API',
      action: 'ai_blend_response',
      requestId,
      success: result.success
    });

    res.json(result);
  } catch (error) {
    logger.error('Blend Images API Error', error, {
      component: 'API',
      action: 'ai_blend_error',
      requestId
    });
    res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

// AI Image Generation endpoint
app.post('/api/ai/generate-image', async (req, res) => {
  try {
    const { prompt, style } = req.body;

    if (!prompt) {
      return res.status(400).json({
        success: false,
        error: 'Prompt is required'
      });
    }

    // This would use Google's Imagen API for actual image generation
    // For now, return a placeholder response
    res.json({
      success: false,
      error: 'Image generation requires Google Imagen API access. This feature is currently in development.'
    });
  } catch (error) {
    logger.error('Generate Image API Error:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

// Graceful shutdown
process.on('SIGTERM', () => {
  logger.info('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

app.listen(PORT, '0.0.0.0', () => {
  logger.info(`ğŸš€ CollageForge Backend running on port ${PORT}`);
  logger.info(`ğŸ“Š Environment: ${process.env.NODE_ENV || 'development'}`);
  logger.info(`ğŸŒ CORS Origin: ${process.env.CORS_ORIGIN || 'localhost'}`);
});